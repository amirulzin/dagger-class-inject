![Version](https://img.shields.io/badge/JCenter-0.1.0-brightgreen)
![License](https://img.shields.io/badge/License-Apache%202.0-blue)

# Dagger Class Inject 

### Preface
For the majority of Dagger users, you don't exactly need this library. Simply provision your Java `Class` object 
in a `@Provider` method in a valid Dagger `@Module` and call it a day e.g.

````java
@Module
public interface SomeModule {
    @Provider
    static Class<SomeTool> providesSomeToolClass(){
        return SomeTool.class;
    }
}
````


However, if you've been doing constructor injection as a good DI citizen, you probably start hating yourself
when the need arise when you want to inject the Java `Class` object itself across the project. 
Normally, having a few of them is fine. However, once it began to balloon up as per your project complexity, you'll probably start looking for a solution to eliminate the tedium. 
Hence, this library is born. 

### Usage
This library automatically generate valid Dagger `Class`  providers for Java classes annotated with `@ClassInject`.
These providers are then written into Dagger modules aptly named as `GeneratedClassProvidersModule`,
which are all graphed into the "root" module, `ClassProvidersModule`.

Root modules are created in the package where `@ClassInjectOrigin` was annotated.
 
Gradle:
````groovy
repositories {
   jcenter()
}

dependencies {
    implementation 'com.redconfig:class-inject-api:0.1.0'
    annotationProcessor 'com.redconfig:class-inject-processor:0.1.0'
}
````
 
 Declaration site:
````java
package com.awesomepackage.deep.nested;

@ClassInject
public class SomeTool { ... }
````
````java      
package com.awesomepackage;
 
@ClassInjectOrigin
public class SomeApp { ... }
````
 After generation:
````java
package com.awesomepackage;

@Component(modules = {
    ClassProvidersModule.class //generated by the library
})
public interface SomeAppComponent { ... }
````
 
 Injection site:
````java
package com.awesomepackage.deep.nested;
     
public class SomeGenericTool {
    @Inject
    public SomeGenericTool(Class<SomeTool> someToolClass){ //tada!
        ...
    }   
    
    public SomeTool doSomethingWithClass(){
        return parseSomething(someToolClass); 
    }       
}
 ````
### Advanced Configuration
By default, the processor works in `modular` mode which produces `GeneratedClassProviderModule` in the
packages where `@ClassInject` is found. This is necessary to support classes with package local visibility.
In certain projects, this may generate a lot of modules and may not be the behavior that you want.

Hence, if you are able to have every `@ClassInject` classes visibility as `public`, the library also provides 
a `monolith` mode. This mode massively cuts down the size of generated modules and it simply provision the class 
directly in the root modules instead.

You can enable `monolith` mode by passing the argument below to the compiler arguments:
````
com.redconfig.classinject.mode=monolith
````
 
e.g. for Gradle :
````groovy
compileJava {
    options.compilerArgs += '-Acom.redconfig.classinject.mode=monolith'
}
```` 

### Known Issues

The library was made with Dagger `2.26`. It is however possible to encounter a compilation error on versions below `2.26` 
due to Dagger missing some annotations. If you encounter such issue, please upgrade to the latest 
Dagger library (or anything above 2.26+). 

## License

This library is provided under [Apache 2.0](LICENSE.md)